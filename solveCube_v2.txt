#pragma config(Sensor, S1,     ts,             sensorEV3_Touch)
#pragma config(Sensor, S2,     us,             sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     csens,          sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Motor,  motorA,          carm,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          marm,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          plat,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          cspin,         tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
The gear ratio is 1 turn of motor to 3 turns of platform
*/


const int sp =60;
const int turnSpeed=100;
const int holdAngle=295;
const int noHoldAngle=310;
int colRef[]={0,1,2,-1};
void resetArm ();

//safety function

void isSafe (int touch, int dist){
	if (touch||dist>20){
		while(SensorValue[ts]==1);
		while(SensorValue[ts]==0||SensorValue[us]>20);
		resetArm();
	}
}

void resetArm(){
	//puts arm back to rest position from any position
	if (nMotorEncoder[marm]<0){
		motor[marm]=sp;
		while (nMotorEncoder[marm]<0)
		{}
		motor[marm]=0;
	}
	else{
		motor[marm]=-sp;
		while (nMotorEncoder[marm]>0)
		{}
		motor[marm]=0;
	}
}

void holdCube(){
	//sets the arm down to hold the cube
	if (nMotorEncoder[marm]<-100){
		motor[marm]=sp;
		while (nMotorEncoder[marm]<-165)
		{}
		motor[marm]=0;
	}
	else{
		motor[marm]=-sp;
		while (nMotorEncoder[marm]>-165)
		{}
		motor[marm]=0;
	}
}

void reorientX(int n){
	//reorients along x-axis, only one direction
	for(int i=0;i<n;i++){
		motor[marm]=-sp;
		while(nMotorEncoder[marm]>-240);
		motor[marm]=sp;
		while (nMotorEncoder[marm]<-90);
		wait1Msec(100);
	}
	motor[marm]=sp;
	while (nMotorEncoder[marm]<0);
	motor[marm]=0;
	isSafe(SensorValue[ts], SensorValue[us]);
}

void turnDown(int x, bool hold){
	//turns the platform, x is direction, hold is whether or not marm is down
	int initEnc=nMotorEncoder[plat];
	if (x>0)
		motor[plat]=turnSpeed;
	else
		motor[plat]=-turnSpeed;

	if (hold)
		while (fabs(initEnc-nMotorEncoder[plat])<fabs(holdAngle*x));
	else
		while (fabs(initEnc-nMotorEncoder[plat])<fabs(noHoldAngle*x));

	motor[plat]=0;
	if (x>0)
		motor[plat]=-turnSpeed;
	else
		motor[plat]=turnSpeed;
	while (fabs(initEnc-nMotorEncoder[plat])>fabs(90*3*x));
	motor[plat]=0;
	wait1Msec(125);
	isSafe(SensorValue[ts], SensorValue[us]);
}

//face turns

void U(int x){ // turns the white face
	reorientX(2);
	holdCube();
	turnDown(x, 1);
	resetArm();
	reorientX(2);
}

void D(int x){ // turns the yellow face
	holdCube();
	turnDown(x,1);
	resetArm();
}

int L(int x, int col){ // turns the orange face
	turnDown(colRef[(col+1)%4],0);
	reorientX(1);
	holdCube();
	turnDown(x,1);
	resetArm();
	turnDown(2,0);
	reorientX(1);
	return 1;
}

int R(int x, int col){ // turns the red face
	turnDown(colRef[(col+3)%4],0);
	reorientX(1);
	holdCube();
	turnDown(x,1);
	resetArm();
	turnDown(-2,0);
	reorientX(1);
	return 3;
}

int B(int x, int col){ // turns the blue face

	turnDown(colRef[(col+2)%4],0);
	reorientX(1);
	holdCube();
	turnDown(x,1);
	resetArm();
	turnDown(2,0);
	reorientX(1);
	return 0;

}

int F(int x, int col){ // turns the green face
	turnDown(colRef[col], 0);
	reorientX(1);
	holdCube();
	turnDown(x,1);
	resetArm();
	turnDown(-2,0);
	reorientX(1);
	return 2;
}

void colourScan () {
	int face [6][9];
	for (int i = 0; i < 6; i++) {
		//scanning
		if (i > 0 && i < 4)
			reorientX(1);
		else if (i == 4) {
			turnDown (1, false);
			reorientX(1);
		}
		else if (i == 5)
			reorientX(2);

		motor[carm]=15;
		while(nMotorEncoder[carm]<30)
		{}
		wait1Msec(200);
		motor[carm]=5;
		while(nMotorEncoder[carm]<30)
		{}
		wait1Msec(500);

		for(int r = 1; r < 9; r++)
		{
			wait1Msec(100);
			motor[cspin]=-5;
			while(nMotorEncoder[cspin]>-45*(r))
			{
				wait1Msec(50);
				face [i][r] = SensorValue [csens];
			}
			motor[cspin]=0;
		}
		motor[cspin]=20;
		while(nMotorEncoder[cspin]<0)
		{}
		motor[cspin]=0;
		motor[carm]=-10;
		while(nMotorEncoder[carm]>5)
		{}
		motor[carm]=0;
	}
	turnDown(-1, false);
	reorientX(1);
	turnDown (2, false);

	//}
	/*
	for (int c = 1; c < 8; c++)
	{
	if (face[c]> 30 && face[c]<44)
	colour[c]="Blue";
	else if (face[c] > 44 && face[c] < 100)
	colour[c]="Green";
	else if (face[c] > 100 && face[c] < 146)
	colour[c]="Red";
	else if (face[c] > 146 && face[c] < 166)
	colour[c]="Yellow";
	else if (face[c] > 166 && face[c] < 175)
	colour[c]="Orange";
	else
	colour[c]="White";
	} */
	for (int i = 0; i < 6; i++)
		face [i] [0] = -1;
	displayString(0,"%d     %d     %d", face [i] [3], face [0] [4], face [0] [5]);
	displayString(2,"%d     %d     %d", face [i] [2], face [0] [0], face [0] [6]);
	displayString(4,"%d     %d     %d", face [i] [1], face [0] [8], face [0] [7]);


	//	displayString(i,"%d", face [i]);
	wait1Msec (500000);

}


task main()
{
	colourScan (); //WHITE BLUE YELLO GREEN RED BLACK
	int c=0; // ranges from 0 to 3, optimizes movement

	//checkerboard pattern x10
	//for(int i=0;i<10;i++){
	//	D(2);
	//	U(-2);
	//	c=L(2,c);
	//	c=R(-2,c);
	//	c=F(2,c);
	//	c=B(-2,c);
	//}

	while(SensorValue[ts]==0||SensorValue[us]>20);
	ClearTimer(T1);

	//copy and paste output from moveTranscriber.cpp below
	D(1);
	c=F(-1, c);
	c=B(1, c);
	c=L(-1, c);
	U(-1);
	c=F(1, c);
	c=L(2, c);
	c=F(-1, c);
	c=L(2, c);
	c=B(1, c);
	c=L(2, c);
	D(-1);
	c=R(-2, c);
	U(-1);
	c=L(2, c);
	U(1);
	c=F(2, c);
	c=R(-2, c);
	c=F(2, c);
	D(-1);
	c=R(-2, c);
	U(2);

	//careful not to erase this stuff
	float solveTime=time1[T1]/1000.0;
	displayString(0,"%f",solveTime);
	while (SensorValue[ts]==0);
}
